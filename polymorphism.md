Polymorphism and modal parametricity via □-modality
===================================================

[author]: mailto:a@kuklev.com "Alexander Kuklev, JetBrains Research"
[Alexander Kuklev](mailto:a@kuklev.com), [JetBrains Research](https://research.jetbrains.org/researchers/alexander.kuklev/)

# Base theory

We'll be working in an {0, ω}-graded intuitionistic type theory with a countable hierarchy of universes closed under 𝟘𝟙𝔹ℕΣΠ type formers:

```
––––––––————    ––––––––————    ––––––––————    ––––––––————    ––––––––————
Γ ⊢ * : *⁺       Γ ⊢ 𝟘 : *       Γ ⊢ 𝟙 : *       Γ ⊢ 𝔹 : *       Γ ⊢ ℕ : *


 Γ ⊢ X : *     Γ, x : X ⊢ Y(x) : *       Γ ⊢ X : *     Γ, x : X ⊢ Y(x) : *
––––––––————–––––––––––—————————————    ––––––––——––––––––––––—————————————— 
      Γ ⊢ (x : Y) × Y(x) : *                  Γ ⊢ ∀(x : Y) Y(x) : *
```

Polymorphic rules (the ones containing `*`) are shorthands for a rule schemes generated by substituting all instances of `*` inside the rule by `U`, `U⁺`, `U⁺⁺`, etc. For instance the first rule above is a shorthand for
```
––––––––————     ––––––––——————     ––––––––—————————     ···
 Γ ⊢ U : U⁺       Γ ⊢ U⁺ : U⁺⁺       Γ ⊢ U⁺⁺ : U⁺⁺⁺
```

These rules simulaneously introduce the terms U, U⁺,... and their types, as well as define the action of ( ⁺) operator on them. Its action on the other types will be defined on case-by-case basis for all type formers (i.e. coinductively):
```
 Γ ⊢ T : U
––––––––—–——
  T⁺ ↦ T

        Γ, x : X ⊢ Y(x) : *
–––––––—–————————————————————————————————
 ((x : Y) × Y(x))⁺ ↦ (x : Y⁺) × (Y(x))⁺

        Γ, x : X ⊢ Y(x) : *
–––––––—–————————————————————————————————
  (∀(x : Y) Y(x))⁺ ↦ ∀(x : Y⁺) × (Y(x))⁺    
```

It shifts the universe levels in types built using universes, e.g. `(U → U)⁺` should be `(U⁺ → U⁺)`, while doing nothing for types inside the base universe as they cannot involve universes in their definitions.

{0, ω}-grading means that we can introduce rules where some variables are allowed to be used computationally irrelevantly, so can introduce parametric quantifiers `∀<x : X> T(x)` (angle brackets instead of parens):
```
 Γ ⊢ X : *     Γ, x : X ⊢ Y(x) : *
––––––––————–––––––––––—————————————
   Γ ⊢ ∀<x : Y> Y(x) : *

 Γ ⊢ X : *   Г, x :° X ⊢ y : Y(X)
––––––––––––––––––––––––—————————————
 Г ⊢ (x :° X ↦ Y(X)) : ∀<x : Y> Y(x) 
```

Most notably, {0, ω}-grading also allows to introduce the S4 neccesity □-modality mapping types `T` to their sets of closed-form inhabitants `t : □T`:
```
   □Г ⊢ x : X
————————————————
 □Г, Δ ⊢ x : □X

 Г ⊢ x : □X     Г, u :□ X ⊢ y : Y
———————————————————————————————————
     Г ⊢ (let u = x; y) : Y 

 □Г, x : X ⊢ y : □Y(x)
=======================
 Г, x :° X ⊢ y : Y(X)
```

Now we can write down the polymorphic cummulativity rule: all closed-form typeformers defined for some universe are also applicable to all higher universes:
```
 Γ, K : *⁺ ⊢ F : □(K → *)
———————————————————————————
     Γ ⊢ F : K⁺ → *⁺
```

With this rule polymorphic type definitions such as `List<T : U> : U`, `GroupStructureOn(T : U)`, CatStructureOn(Ob : U, Hom : Ob → Ob → U), and `GroupHomomorphism((X : U) × GroupStructureOn(X) × (Y : U) × GroupStructureOn(Y))` become applicable to types from any universes, as if they were introduced by polymorphic rules like 
```
  Γ ⊢ T : *
–––––––––––––
 List<T> : * 
```

Now we can also write down polymorphic lifting rule: polymorphic proofs/definitions are automatically applicable in all higher universes. 
```
 Γ, K : U⁺ ⊢ F : □(K → U)
 Γ ⊢ c : □∀<T : K> F(T)
————————————————————————————————————————————
 Γ ⊢ c : ∀<T : K⁺> F(T)
```

For example, assume we have proven the Cayley's embedding theorem for U-small groups:
```
cayleyEmbedding : ∀<G : U> ∀(g : GroupStructureOn<G>) GroupHomomorphism((G, g), sym(G))
```

With the rule above, it automatically applies also to groups in any universe U.

Note that the coinductively defined operator ( ⁺) is very similar to the coinductively defined operator ( ᵈ) in Displayed Type Theory, which allows to derive the polymoprhic displayed category of all groups `CatStructureOn OGroupStructureOn GroupHomomorphism` from already defined type polymorphic type classes above. Given a proof of, say, Yoneda's lemma, for U-small categories we actually want it to be applicable not only for categories of arbitrary size, but also for arbitrary displayed categories, which now can be achieved using a simple generalization of the polymorphic lifting rule.
