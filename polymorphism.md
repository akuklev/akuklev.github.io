â—‡Classical and â–¡Parametric Modalities for Martin-LÃ¶f Type Theories
==================================================================

[author]: mailto:a@kuklev.com "Alexander Kuklev, JetBrains Research"
[Alexander Kuklev](mailto:a@kuklev.com), [JetBrains Research](https://research.jetbrains.org/researchers/alexander.kuklev/)

# Base theory

We'll be working in an intuitionistic type theory with a countable hierarchy of universes closed under ğŸ˜ğŸ™ğ”¹â„•Î£Î  type formers:

```
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”
Î“ âŠ¢ * : *âº       Î“ âŠ¢ ğŸ˜ : *       Î“ âŠ¢ ğŸ™ : *       Î“ âŠ¢ ğ”¹ : *       Î“ âŠ¢ â„• : *


 Î“ âŠ¢ X : *     Î“, x : X âŠ¢ Y(x) : *       Î“ âŠ¢ X : *     Î“, x : X âŠ¢ Y(x) : *
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 
      Î“ âŠ¢ (x : Y) Ã— Y(x) : *                  Î“ âŠ¢ âˆ€(x : Y) Y(x) : *
```

Rules containing `*` are shorthands for a rule schemes generated by substituting all instances of `*` inside the rule by `U`, `Uâº`, `Uâºâº`, etc. For instance the first rule above is a shorthand for
```
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”     â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”     â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”     Â·Â·Â·
 Î“ âŠ¢ U : Uâº       Î“ âŠ¢ Uâº : Uâºâº       Î“ âŠ¢ Uâºâº : Uâºâºâº
```

These rules simulaneously introduce the terms U, Uâº,... and their types, as well as define the action of ( âº) operator on them. Its action on the other types will be defined on case-by-case basis for all type formers (i.e. coinductively):
```
 Î“ âŠ¢ T : U
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€“â€”â€”
  Tâº â†¦ T

        Î“, x : X âŠ¢ Y(x) : *
â€“â€“â€“â€“â€“â€“â€“â€”â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
 ((x : Y) Ã— Y(x))âº â†¦ (x : Yâº) Ã— (Y(x))âº

        Î“, x : X âŠ¢ Y(x) : *
â€“â€“â€“â€“â€“â€“â€“â€”â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  (âˆ€(x : Y) Y(x))âº â†¦ âˆ€(x : Yâº) Ã— (Y(x))âº    
```

It shifts the universe levels in types built using universes, e.g. `(U â†’ U)âº` should be `(Uâº â†’ Uâº)`, while doing nothing for types inside the base universe as they cannot involve universes in their definitions.



In 2016 C. McBride [introduced](https://link.springer.com/chapter/10.1007/978-3-319-30936-1_12) graded type theories with exact control over the number of computationally relevant argument usages: 
```
x : X -- as often as desired
x :â»X -- use at most once
x :Â¹X -- use exactly most once
x :âºX -- use at least once
x :â°X -- virtual argument, use only in type annotations
```

In a type theory with :â° we can introduce parametric quantifiers `âˆ€<a>` and closed-form


In intutionistic type theories, negation `Â¬T` is encoded as the function type `T â†’ âŠ¥`. A proof that requires an assumption `nT : Â¬T` can employ
this assumption to cut excluded cases when performing case analysis. For instance, a value `v : P + T` can be matched by `{ inl(p) â†¦ ... ; inr(t) â†¦ nT(t) }`.
Due to ex-falso-quodlibet (the recursion operator of the empty type âŠ¥), the excluded branch `nT(t)` can typecheck against any type.

Proofs by contradiction assume a negative premise `nT : Â¬T` to derive a contradiction `âŠ¥`. One way to arrive at a contradiction is to construct a counter-example `t : T` and feed it into `nT(t)` thus yielding a contradiction. In general, a proof can require multiple negative premises, and use only one of them, so it is not guaranteed that every negative premise is used. On the other hand, such a premise can be used inside an internal recursive subproof to cut branches, so it can be used unbounded number of times. However, if we require such a premise to be used exactly once, we can extract a counterexample from a proof by contradiction:
```
 prf : Â¬(nT :Â¹Â¬T)
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   Îµáµ€(prf) : T
```

Otherwise, the extraction will be non-determinstic. However, we can introduce modalities of spectra â—‡âº, â—‡â» and â—‡, meaning â€œone or more possible outcomeâ€, â€one or less outcomesâ€ and â€œany number of possible outcomesâ€. With this modalities we have:
```
 prf : Â¬(nT :âºÂ¬T)      prf : Â¬(nT :â»Â¬T)        prf : Â¬Â¬T
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”    â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”    â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  Îµáµ€(prf) : â—‡âºT         Îµáµ€(prf) : â—‡â»T        Îµáµ€(prf) : â—‡T
```

For the rest of this paper will not consider the substructural modes (â», Â¹, âº) and modal operators (â—‡âº, â—‡â»), and only consider the truly remarkable third rule above. It's the classical choice operator, which means we can presummably use classical reasoning (with excluded middle and choice) under the â—‡-modality!  `â—‡T` is the type of hypothetically possible inhabitants of `T`, yet will argue that it has a sound computational^[Versal functions only compute on introspectable (finite, closed) arguments, they cannot be applied to an â€œexternal functionâ€ (which can be applied to any value, but not introspected) nor an arbitrary (Cauchy) real number. This is in strong opposition to the total functions outside â—‡-modality which are guaranteed to compute also on external entities. Verse calculus seems to provide a Krivine-type realizability interpretation for classical logic with choice, while general MLTT provide stronger Kreisel-type realizability for intuitionistic logic.] interpretation in terms of the Verse Calculus recently introduced by S. Peyton Jones et al. We will also introduce the dual types `â–¡T` of â€œmanifestly neccesaryâ€ inhabitants of `T`, i.e. finite closed terms, yielding the well-known computational interpretation in terms of staged computability. Dually to classical reasoning under â—‡-modality, we obtain parametric reasoning under â–¡-modality, so that we can show that `{ x â†¦ x }` in the only canonical endomorphism of an arbitrary type up to equivalence: `âˆ€(id : â–¡âˆ€(T : *) T â†’ T) id â‰ƒ { x â†¦ x }`.

By establishing a set-theoretic interpretation of types under â—‡-modality, we will show admissibility of the following rule that allows using finite closed non-constructive proofs as virtual arguments outside of the â—‡-context:
```
 f : (x :Â° X) â†’ Y      x : â–¡â—‡X
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
          f(x) : Y
```

We will show that this rule implies (and essentially is) the computational Markov principle allowing to evaluate (potentially diverging by virtue of halting problem) computations given a finite closed classical proof of their non-divergence: 
```
 c : (Computation T)   nonDivergencePrf : â–¡â—‡(c â‰  âŠ¥)
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
          eval(c, nonDivergencePrf) : T
```

We will show that even in presence computational of Markov principle, all explicitly definable functions `f : â–¡(X â†’ Y)` are continuous with respect to the topology given by positively semi-decidable predicates which is also the usual open-ball topology for all types constructed as Cauchy completions.

In presence of Â°- and â–¡-modality it is possible to introduce a reflective virtial universe ğ•Š and postulate existence of ordinary universes closed under any finite number of closed-definable type formers, yielding a type-theoretic counterpart (and pressumably an equiconsistent conservative extension) of M. Shulman's â€œSet theory for category theoryâ€ ZMC/ğ•Š. These features make the proposed system an optimal foundation for a proof assistaint. For practical usability as a functional programming language, the system has to be extended with indexed modalities for size-guarded recursion and clock-guarded corecursion, which are known to be eliminable towards of ordinary recursion and corecursion at cost of substantial complexity blowup.

In a [companion paper](reedy-types), we outline how to extend Martin-LÃ¶f type theories including the one proposed in this paper to allow structural induction over their own languages, extending the notion of types from âˆ-groupoids to Ï‰-categories as a natural by-product.

# The closed term modality â–¡ and virtual arguments
```
   â–¡Ğ“ âŠ¢ x : X
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
 â–¡Ğ“, Î” âŠ¢ x : â–¡X

 Ğ“ âŠ¢ x : â–¡X     Ğ“, u :â–¡ X âŠ¢ y : Y
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
     Ğ“ âŠ¢ (let u = x; y) : Y 

 â–¡Ğ“, x : X âŠ¢ y : â–¡Y(x)
=======================
 Ğ“, x :Â° X âŠ¢ y : Y(X)
```

# The spectral modality â—‡ and perceived entanglement

# Spectral quantifiers and canonical quantifiers

# The Markov principle

# Unary parametricity

# Interpreting classical logic

# Interpreting verse calculus

Verse calculus is a functional logic programming language, which implies that a finite closed â€œprogramâ€ can be evaluated:
```
         prgm : â–¡â—‡P
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
 eval(prgm) : PolyComputation P
```

Where PolyComputation is a monad similar to the Computation monad, but allowing to yield multiple, potentially infinutely many values, a computational stream modulo order and multiplicity of values.

Such â€œevalâ€œ operator gives the â€œallâ€ operator of Verse Calculus, while Îµáµ€ gives â€œoneâ€ operator.

# Reflective universes

# Embedding of the type-theoretic model of ZF-sets into â—‡ by Zakharyaschev subframe canonical formulae

# Set-theoretic model a la Pujet-Tabareau and conservativity via back-and-fourth argument

# Normalization for the modal-free fragment and admissibility of Markov principle

# Future work: Canonicity for the â–¡-fragment, productivity for the â—‡-fragment

The former means that the â€œstreamâ€ `eval(prgm : â–¡â—‡P)` is productive and dense in the spectrum `â—‡P` with respect to the topology given by positively semi-decidable predicates.

Check if we can show that types with verifiable equality are formally subcountable:
```
âˆ€(T : *) verifiable(T) â†’ â—‡(â„• â‡€ â–¡T)
```

Check if we can also show that types with falsifiable equality are formally completely separable.
