Polymorphism and modal parametricity via â–¡-modality
===================================================

[author]: mailto:a@kuklev.com "Alexander Kuklev, JetBrains Research"
[Alexander Kuklev](mailto:a@kuklev.com), [JetBrains Research](https://research.jetbrains.org/researchers/alexander.kuklev/)

# Base theory

We'll be working in an {0, Ï‰}-graded intuitionistic type theory with a countable hierarchy of universes closed under ğŸ˜ğŸ™ğ”¹â„•Î£Î  type formers:

```
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”
Î“ âŠ¢ * : *âº       Î“ âŠ¢ ğŸ˜ : *       Î“ âŠ¢ ğŸ™ : *       Î“ âŠ¢ ğ”¹ : *       Î“ âŠ¢ â„• : *


 Î“ âŠ¢ X : *     Î“, x : X âŠ¢ Y(x) : *       Î“ âŠ¢ X : *     Î“, x : X âŠ¢ Y(x) : *
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”    â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 
      Î“ âŠ¢ (x : Y) Ã— Y(x) : *                  Î“ âŠ¢ âˆ€(x : Y) Y(x) : *
```

Polymorphic rules (the ones containing `*`) are shorthands for a rule schemes generated by substituting all instances of `*` inside the rule by `U`, `Uâº`, `Uâºâº`, etc. For instance the first rule above is a shorthand for
```
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”     â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”     â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”     Â·Â·Â·
 Î“ âŠ¢ U : Uâº       Î“ âŠ¢ Uâº : Uâºâº       Î“ âŠ¢ Uâºâº : Uâºâºâº
```

These rules simulaneously introduce the terms U, Uâº,... and their types, as well as define the action of ( âº) operator on them. Its action on the other types will be defined on case-by-case basis for all type formers (i.e. coinductively):
```
 Î“ âŠ¢ T : U
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€“â€”â€”
  Tâº â†¦ T

        Î“, x : X âŠ¢ Y(x) : *
â€“â€“â€“â€“â€“â€“â€“â€”â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
 ((x : Y) Ã— Y(x))âº â†¦ (x : Yâº) Ã— (Y(x))âº

        Î“, x : X âŠ¢ Y(x) : *
â€“â€“â€“â€“â€“â€“â€“â€”â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  (âˆ€(x : Y) Y(x))âº â†¦ âˆ€(x : Yâº) Ã— (Y(x))âº    
```

It shifts the universe levels in types built using universes, e.g. `(U â†’ U)âº` should be `(Uâº â†’ Uâº)`, while doing nothing for types inside the base universe as they cannot involve universes in their definitions.

{0, Ï‰}-grading means that we can introduce rules where some variables are allowed to be used computationally irrelevantly, so can introduce parametric quantifiers `âˆ€<x : X> T(x)` (angle brackets instead of parens):
```
 Î“ âŠ¢ X : *     Î“, x : X âŠ¢ Y(x) : *
â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   Î“ âŠ¢ âˆ€<x : Y> Y(x) : *

 Î“ âŠ¢ X : *   Ğ“, x :Â° X âŠ¢ y : Y(X)
â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
 Ğ“ âŠ¢ (x :Â° X â†¦ Y(X)) : âˆ€<x : Y> Y(x) 
```

Most notably, {0, Ï‰}-grading also allows to introduce the S4 neccesity â–¡-modality mapping types `T` to their sets of closed-form inhabitants `t : â–¡T`:
```
   â–¡Ğ“ âŠ¢ x : X
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
 â–¡Ğ“, Î” âŠ¢ x : â–¡X

 Ğ“ âŠ¢ x : â–¡X     Ğ“, u :â–¡ X âŠ¢ y : Y
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
     Ğ“ âŠ¢ (let u = x; y) : Y 

 â–¡Ğ“, x : X âŠ¢ y : â–¡Y(x)
=======================
 Ğ“, x :Â° X âŠ¢ y : Y(X)
```

Now we can write down the polymorphic cummulativity rule: all closed-form typeformers defined for some universe are also applicable to all higher universes:
```
 Î“, K : *âº âŠ¢ F : â–¡(K â†’ *)
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
     Î“ âŠ¢ F : Kâº â†’ *âº
```

With this rule polymorphic type definitions such as `List<T : U> : U`, `GroupStructureOn(T : U)`, CatStructureOn(Ob : U, Hom : Ob â†’ Ob â†’ U), and `GroupHomomorphism((X : U) Ã— GroupStructureOn(X) Ã— (Y : U) Ã— GroupStructureOn(Y))` become applicable to types from any universes, as if they were introduced by polymorphic rules like 
```
  Î“ âŠ¢ T : *
â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
 List<T> : * 
```

Now we can also write down polymorphic lifting rule: polymorphic proofs/definitions are automatically applicable in all higher universes. 
```
 Î“, K : Uâº âŠ¢ F : â–¡(K â†’ U)
 Î“ âŠ¢ c : â–¡âˆ€<T : K> F(T)
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
 Î“ âŠ¢ c : âˆ€<T : Kâº> F(T)
```

For example, assume we have proven the Cayley's embedding theorem for U-small groups:
```
cayleyEmbedding : âˆ€<G : U> âˆ€(g : GroupStructureOn<G>) GroupHomomorphism((G, g), sym(G))
```

With the rule above, it automatically applies also to groups in any universe U.

Note that the coinductively defined operator ( âº) is very similar to the coinductively defined operator ( áµˆ) in Displayed Type Theory, which allows to derive the polymoprhic displayed category of all groups `CatStructureOn OGroupStructureOn GroupHomomorphism` from already defined type polymorphic type classes above. Given a proof of, say, Yoneda's lemma, for U-small categories we actually want it to be applicable not only for categories of arbitrary size, but also for arbitrary displayed categories, which now can be achieved using a simple generalization of the polymorphic lifting rule.
